import 'dart:convert';
import 'dart:io';

import 'package:dairy_app/core/logger/logger.dart';
import 'package:dairy_app/features/notes/domain/repositories/export_notes_repository.dart';
import 'package:dairy_app/features/notes/domain/repositories/notes_repository.dart';
import 'package:flutter/services.dart';
import 'package:flutter_html_to_pdf/flutter_html_to_pdf.dart';
import 'package:intl/intl.dart';
import 'package:path_provider/path_provider.dart';

final log = printer("ExportNotesRepository");

class ExportNotesRepository implements IExportNotesRepository {
  final INotesRepository notesRepository;

  ExportNotesRepository({required this.notesRepository});

  @override
  Future<String> exportNotesToTextFile(
      {required File file, List<String>? noteList}) async {
    try {
      if (noteList == null) {
        log.i("Generating text file for all notes");

        final result = await notesRepository.fetchNotes();

        var fileContent = "";

        result.fold((l) => null, (allNotes) async {
          for (var note in allNotes) {
            fileContent += note.title + "\n";

            fileContent += "Created at: " + formatDate(note.createdAt) + "\n";
            fileContent += note.plainText;
            fileContent += "\n\n---------------------------------\n\n";
          }
        });
        await file.writeAsString(fileContent);

        return file.path;
      }

      return "";
    } catch (e) {
      log.e(e);
      rethrow;
    }
  }

  @override
  Future<String> exportNotesToPDF({List<String>? noteList}) async {
    // create a text file from the notes
    final directory = await getApplicationDocumentsDirectory();
    final file = File('${directory.path}/diaryvault_notes_export.txt');

    try {
      if (noteList == null) {
        log.i("Generating PDF for all notes");

        final result = await notesRepository.fetchNotes();

        // Add watermark

        var fileContent = "";

        String watermarkFile =
            await getImageFileFromAssets('assets/images/watermark.webp');

        fileContent +=
            "<img width=\"1000\" src=\"$watermarkFile\"  alt=\"web-img\">";

        result.fold((l) => null, (allNotes) async {
          for (var note in allNotes) {
            fileContent += "<h2>${note.title}</h2>";

            fileContent += "<i>Created at: ${formatDate(note.createdAt)} </i>";
            fileContent += "<br>";

            final preprocessedDelta = preprocessDeltaForPDFExport(note.body);
            fileContent += quillDeltaToHtml(preprocessedDelta);

            fileContent += "<hr><br>";
          }
        });

        await file.writeAsString(fileContent);
        var generatedPdfFile = await FlutterHtmlToPdf.convertFromHtmlFile(
            file, directory.path, "diayvault_pdf_export");

        return generatedPdfFile.path;
      }

      return "";
    } catch (e) {
      log.e(e);
      rethrow;
    }
  }

  // utils

  String quillDeltaToHtml(String delta) {
    var deltaMap = jsonDecode(delta);
    var html = StringBuffer();

    for (var op in deltaMap) {
      if (op["insert"] is String) {
        var text = op["insert"] as String;
        var attributes = op["attributes"] as Map<String, dynamic>?;

        if (attributes != null) {
          if (attributes.containsKey("bold")) {
            text = "<strong>$text</strong>";
          }
          if (attributes.containsKey("italic")) {
            text = "<em>$text</em>";
          }
          // Add more attribute handling as needed
        }

        html.write(text);
      } else if (op["insert"] is Map) {
        var insert = op["insert"] as Map<String, dynamic>;
        if (insert.containsKey("image")) {
          var image = insert["image"] as Map<String, dynamic>;
          html.write(
              '<img src="${image['src']}" width="${image['width']}" height="${image['height']}" style="max-width: 100%; height: auto;">');
        }
        // Handle other insert types as needed
      }
    }

    return html.toString();
  }

  String formatDate(DateTime date) {
    return DateFormat.yMMMEd().format(date) +
        ", " +
        DateFormat.jm().format(date);
  }

  Future<String> getImageFileFromAssets(String assetPath) async {
    final ByteData data = await rootBundle.load(assetPath);
    final List<int> bytes = data.buffer.asUint8List();
    final String base64Image = base64Encode(bytes);

    final String dataUri = 'data:image/png;base64, $base64Image';
    return dataUri;
  }

  // PDF is generated by converting delta to markdown and then to HTML
  // Some elements and attributes are not supported for conversion or needs modification
  String preprocessDeltaForPDFExport(String delta) {
    var deltaMap = jsonDecode(delta);

    for (Map<String, dynamic> deltaElement in deltaMap) {
      // Handle image elements
      if (deltaElement.containsKey("insert") &&
          deltaElement["insert"] is Map &&
          deltaElement["insert"].containsKey("image")) {
        var imageUrl = deltaElement["insert"]["image"] as String;

        // Prefix local images with file:///
        if (!imageUrl.startsWith("http")) {
          imageUrl = "file://" + imageUrl;
        }

        // Add width and height attributes to limit image size
        deltaElement["insert"]["image"] = {
          "src": imageUrl,
          "width": "500", // You can adjust this value as needed
          "height": "auto" // This maintains the aspect ratio
        };
      }

      // Remove unsupported attributes on text
      if (deltaElement.containsKey("insert") &&
          deltaElement["insert"] is String &&
          deltaElement.containsKey("attributes")) {
        var attributes = deltaElement["attributes"] as Map<String, dynamic>;

        // Remove specific unsupported attributes
        attributes.removeWhere((key, value) => [
              "underline",
              "strike",
              "color",
              "background",
              "list",
              "script"
            ].contains(key));

        // If all attributes are removed, remove the attributes key entirely
        if (attributes.isEmpty) {
          deltaElement.remove("attributes");
        }
      }
    }

    return jsonEncode(deltaMap);
  }
}
